java的设计模式大体上分为三大类：
创建型模式（5种）：工厂方法模式，抽象工厂模式，单例模式，建造者模式，原型模式。
结构型模式（7种）：适配器模式，装饰器模式，代理模式，外观模式，桥接模式，组合模式，享元模式。
行为型模式（11种）：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。
设计模式遵循的原则有6个：
1、开闭原则（Open Close Principle）

　　对扩展开放，对修改关闭。

2、里氏代换原则（Liskov Substitution Principle）

　　只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。

3、依赖倒转原则（Dependence Inversion Principle）

　　这个是开闭原则的基础，对接口编程，依赖于抽象而不依赖于具体。

4、接口隔离原则（Interface Segregation Principle）

　　使用多个隔离的借口来降低耦合度。

5、迪米特法则（最少知道原则）（Demeter Principle）

　　一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。

6、合成复用原则（Composite Reuse Principle）

　　原则是尽量使用合成/聚合的方式，而不是使用继承。继承实际上破坏了类的封装性，超类的方法可能会被子类修改。

单例模式：某个类只能有一个实例，提供一个全局的访问点。

简单工厂：一个工厂类根据传入的参量决定创建出那一种产品类的实例。

工厂方法：定义一个创建对象的接口，让子类决定实例化那个类。

抽象工厂：创建相关或依赖对象的家族，而无需明确指定具体类。

建造者模式：封装一个复杂对象的构建过程，并可以按步骤构造。

原型模式：通过复制现有的实例来创建新的实例。

 

适配器模式：将一个类的方法接口转换成客户希望的另外一个接口。

组合模式：将对象组合成树形结构以表示“”部分-整体“”的层次结构。

装饰模式：动态的给对象添加新的功能。

代理模式：为其他对象提供一个代理以便控制这个对象的访问。

亨元（蝇量）模式：通过共享技术来有效的支持大量细粒度的对象。

外观模式：对外提供一个统一的方法，来访问子系统中的一群接口。

桥接模式：将抽象部分和它的实现部分分离，使它们都可以独立的变化。

 

模板模式：定义一个算法结构，而将一些步骤延迟到子类实现。

解释器模式：给定一个语言，定义它的文法的一种表示，并定义一个解释器。

策略模式：定义一系列算法，把他们封装起来，并且使它们可以相互替换。

状态模式：允许一个对象在其对象内部状态改变时改变它的行为。

观察者模式：对象间的一对多的依赖关系。

备忘录模式：在不破坏封装的前提下，保持对象的内部状态。

中介者模式：用一个中介对象来封装一系列的对象交互。

命令模式：将命令请求封装为一个对象，使得可以用不同的请求来进行参数化。

访问者模式：在不改变数据结构的前提下，增加作用于一组对象元素的新功能。

责任链模式：将请求的发送者和接收者解耦，使的多个对象都有处理这个请求的机会。

迭代器模式：一种遍历访问聚合对象中各个元素的方法，不暴露该对象的内部结构。

说明，《如何学习设计模式》转摘自：http://blog.csdn.net/yqj2065/article/details/39103857

 学习技巧
学习设计模式时，有一些技巧能够帮助你快速理解设计模式。

a)   使用较简单的面向对象的语言如Java、C#。GoF的[设计模式]实质上是面向对象的设计模式。[GoF·1.1]中提到“程序设计语言的选择非常重要，它将影响人们理解问题的出发点”。从学习设计模式的角度看，Java和C#较C++更容易一些。比如Java接口等，能够更有效展现设计模式的意图。

b)   使用工具BlueJ。BlueJ最大的好处，就是提供了简单的类图。正如我在简明设计模式Java中所做的，较少去专门画类图，而是在BlueJ中截图。在学生上机编写演示程序时，常常先看他的类图，以判断他的程序是否正确，必要时再看源代码。

c)   日常生活的隐喻。用一些实际生活中的例子来说明某某模式，能够让你快速掌握某模式的目的和实现代码的结构。同时，你要认识到，这种隐喻如同告诉你（2+3）2=22+2*2*3+32，你需要自己举一反三，得出（a+b）2=a2+2ab+b2。在实际工作中的模式的具体应用，则相当于应用代数公式。

d)    动手实践和怀疑精神。看显浅的参考书或上网查阅资料时，要自己敲(复制也可以)代码并运行，要多修改别人的源代码提出自己的观点：为什么书中不这样设计、为什么要那样设计；如果增添一些方法、方法参数、或成员变量会如何？必须要自己亲自动手，最起码要运行。另外，要敢于向博主提问、拍砖。你甚至可以质疑GoF的某些章节的解说和意图，更何况一些博主呢。

基础知识
这些知识让你知道，设计模式好在何处。

a)    面向对象范式。也就是人们传说的思想。封装、继承和多态这些东西，在我看来比if、for等稍微高一点，也属于语法问题。面向对象编程要掌握的三大原则是柏拉图(Plato)原则、里氏(Liskov)替换原则和Parnas原则。这三个原则其实非常简单。任何原则，你觉得很难一见钟情，很难快速认同，那它就不会是好原则。

b)    设计原则。许多人列举了7大原则，如单一职责原则、开闭原则、里氏代换原则、依赖倒转原则、接口隔离原则、合成复用原则、迪米特法则。LSP，我将它提升为面向对象范式的3大基石之一；单一职责和接口隔离，主要作为面向对象分析/OOA时职责划分所遵循的原则，此时你可以不太在意。依赖倒转原则，我把它作为垃圾扔掉，因为开闭原则或者直接地说“依赖于抽象类型原则”已经包含了依赖倒转原则的精华，而依赖倒转原则的糟粕由IoC继承。当然，回调，我很强调。所以，你要掌握的有抽象依赖原则(OCP)、单向依赖原则(含对回调的学习)和最低依赖原则(合成复用原则、迪米特法则)。

c)    UML的初步了解。这是学习设计模式的工具。在早期，你甚至可以仅了解BlueJ的相关图示，也就10分钟的事情。


=====

https://blog.csdn.net/arhaiyun/article/details/77806475

23种经典设计模式UML类图汇总

车的类图结构为<<abstract>>，表示车是一个抽象类；
它有两个继承类：小汽车和自行车；它们之间的关系为实现关系，使用带空心箭头的虚线表示；
小汽车为与SUV之间也是继承关系，它们之间的关系为泛化关系，使用带空心箭头的实线表示；
小汽车与发动机之间是组合关系，使用带实心箭头的实线表示；
学生与班级之间是聚合关系，使用带空心箭头的实线表示；
学生与身份证之间为关联关系，使用一根实线表示；
学生上学需要用到自行车，与自行车是一种依赖关系，使用带箭头的虚线表示
--------------------- 
作者：arhaiyun 
来源：CSDN 
原文：https://blog.csdn.net/arhaiyun/article/details/77806475 
版权声明：本文为博主原创文章，转载请附上博文链接！

★★★★★
类型  模式名称  学习难度  使用频率
===

https://www.cnblogs.com/yw-ah/p/5853252.html
java设计模式类图大全
近来在看书实现GoF的23个设计模式，自己一点点地用建模工具按照自己的理解画出类图（是比较符合我个人思考理解的，个人觉得比通用类图更详细些），碰巧找到了一个挺好用的UML建模工具StarUML，也刚好从该软件中发现其实里面有默认的23个设计模式的通用类图，这就省去了我频繁地找书查看这些类图了，直接将它们保存为图片格式放到手机里面，是不是地就可以拿出来看看那，思考理解一下各个设计模式的原理，最后将它们记在脑里。在此给出这些好用的类图与大家互相学习共同进步！
（按各个设计模式的英文名称的字典序排列）

====

类图学习：
类图分为三大部分：类名，属性名，方法

各个类之间的关系有以下这些
1 is-a 关系：继承关系

2 接口和实现之间的关系：跟继承的区别在于线条是虚线
3 依赖关系：对象之间最弱的一种关联方式，是临时的关联。一般指局部变量，函数参数，返回值建立的对于其他对象的调用关系。一个类调用被依赖的类中的某些方法而得以完成这个类的一些指责，再类图使用带箭头的虚线表示，箭头从使用类指向被依赖的类。

4 关联：对象之间一种引用关系，比如客户类与订单类之间的关系，这种关系通常使用类的属性表达。
关联分为：一般关联，聚合关联，组合关联；在类图中使用带箭头的实线表示关联，箭头从使用类的执行被关联的类，可以双向的
聚合：表示的has -a关系，是一种不稳定的关系，较强于一般关联。有整体和局部的关系，并且没有整体，局部也可以单独存在。

组合：表示contains-a 关系：是种强烈的包含关系。组合类复制被组合类的生命周期。是一种强的聚合关系。部分不饿能脱离整体的存在。如公司和部门，没有公司，就没有部门。
类图中用实心菱形表示，菱形从局部指向整体。

注意区分聚合和组合:好聚好散，因此聚合的没有组合那么强烈，而组合关系的part是不可单独存在的。
多重关系：

===
创建型模式Creational Pattern

单例模式Singleton Pattern
  ★☆☆☆☆  ★★★★☆

简单工厂模式Simple Factory Pattern
  ★★☆☆☆  ★★★☆☆

工厂方法模式Factory Method Pattern
  ★★☆☆☆  ★★★★★

抽象工厂模式Abstract  Factory Pattern
  ★★★★☆  ★★★★★

原型模式Prototype Pattern
  ★★★☆☆  ★★★☆☆

建造者模式Builder Pattern
  ★★★★☆  ★★☆☆☆
--------------------- 
原文：https://blog.csdn.net/arhaiyun/article/details/77806475 

结构型模式Structural Pattern

适配器模式Adapter Pattern

★★☆☆☆

★★★★☆

桥接模式Bridge  Pattern

★★★☆☆

★★★☆☆

组合模式Composite  Pattern

★★★☆☆

★★★★☆

装饰模式Decorator  Pattern

★★★☆☆

★★★☆☆

外观模式Façade  Pattern

★☆☆☆☆

★★★★★

享元模式Flyweight  Pattern

★★★★☆

★☆☆☆☆

代理模式Proxy  Pattern

★★★☆☆

★★★★☆
--------------------- 
原文：https://blog.csdn.net/arhaiyun/article/details/77806475 

行为型模式Behavioral Pattern

职责链模式Chain  of Responsibility Pattern

★★★☆☆

★★☆☆☆

命令模式Command  Pattern

★★★☆☆

★★★★☆

解释器模式Interpreter  Pattern

★★★★★

★☆☆☆☆

迭代器模式Iterator  Pattern

★★★☆☆

★★★★★

中介者模式Mediator  Pattern

★★★☆☆

★★☆☆☆

备忘录模式Memento  Pattern

★★☆☆☆

★★☆☆☆

观察者模式Observer  Pattern

★★★☆☆

★★★★★

状态模式State  Pattern

★★★☆☆

★★★☆☆

策略模式Strategy  Pattern

★☆☆☆☆

★★★★☆

模板方法模式Template  Method Pattern

★★☆☆☆

★★★☆☆

访问者模式Visitor  Pattern

★★★★☆

★☆☆☆☆
--------------------- 
作者：arhaiyun 
来源：CSDN 
原文：https://blog.csdn.net/arhaiyun/article/details/77806475 

